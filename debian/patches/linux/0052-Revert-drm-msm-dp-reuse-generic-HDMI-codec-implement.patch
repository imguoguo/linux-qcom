From 208d87310b0e7b9ff56e30225a91e8d5ed60fc93 Mon Sep 17 00:00:00 2001
From: Xilin Wu <sophon@radxa.com>
Date: Wed, 30 Jul 2025 16:32:03 +0800
Subject: [PATCH] Revert "drm/msm/dp: reuse generic HDMI codec implementation"

Previous commit caused an error when using HDMI audio.

Link: https://applink.feishu.cn/client/message/link/open?token=AmfHwOsK4gAEaMIvTzZLAAI%3D

This reverts commit 98a8920e7b07641eb1996b3c39b9ce27fc05dbb9.
---
 drivers/gpu/drm/msm/Kconfig         |   1 -
 drivers/gpu/drm/msm/dp/dp_audio.c   | 131 +++++++++++++++++++++++++---
 drivers/gpu/drm/msm/dp/dp_audio.h   |  27 ++++--
 drivers/gpu/drm/msm/dp/dp_display.c |  28 +++++-
 drivers/gpu/drm/msm/dp/dp_display.h |   6 ++
 drivers/gpu/drm/msm/dp/dp_drm.c     |   8 --
 6 files changed, 170 insertions(+), 31 deletions(-)

diff --git a/src/drivers/gpu/drm/msm/Kconfig b/src/drivers/gpu/drm/msm/Kconfig
index 7f127e2ae442..974bc7c0ea76 100644
--- a/src/drivers/gpu/drm/msm/Kconfig
+++ b/src/drivers/gpu/drm/msm/Kconfig
@@ -104,7 +104,6 @@ config DRM_MSM_DPU
 config DRM_MSM_DP
 	bool "Enable DisplayPort support in MSM DRM driver"
 	depends on DRM_MSM
-	select DRM_DISPLAY_HDMI_AUDIO_HELPER
 	select RATIONAL
 	default y
 	help
diff --git a/src/drivers/gpu/drm/msm/dp/dp_audio.c b/src/drivers/gpu/drm/msm/dp/dp_audio.c
index f8bfb908f9b4..70fdc9fe228a 100644
--- a/src/drivers/gpu/drm/msm/dp/dp_audio.c
+++ b/src/drivers/gpu/drm/msm/dp/dp_audio.c
@@ -13,13 +13,13 @@
 
 #include "dp_catalog.h"
 #include "dp_audio.h"
-#include "dp_drm.h"
 #include "dp_panel.h"
 #include "dp_reg.h"
 #include "dp_display.h"
 #include "dp_utils.h"
 
 struct msm_dp_audio_private {
+	struct platform_device *audio_pdev;
 	struct platform_device *pdev;
 	struct drm_device *drm_dev;
 	struct msm_dp_catalog *catalog;
@@ -160,11 +160,24 @@ static void msm_dp_audio_enable(struct msm_dp_audio_private *audio, bool enable)
 	msm_dp_catalog_audio_enable(catalog, enable);
 }
 
-static struct msm_dp_audio_private *msm_dp_audio_get_data(struct msm_dp *msm_dp_display)
+static struct msm_dp_audio_private *msm_dp_audio_get_data(struct platform_device *pdev)
 {
 	struct msm_dp_audio *msm_dp_audio;
+	struct msm_dp *msm_dp_display;
+
+	if (!pdev) {
+		DRM_ERROR("invalid input\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	msm_dp_display = platform_get_drvdata(pdev);
+	if (!msm_dp_display) {
+		DRM_ERROR("invalid input\n");
+		return ERR_PTR(-ENODEV);
+	}
 
 	msm_dp_audio = msm_dp_display->msm_dp_audio;
+
 	if (!msm_dp_audio) {
 		DRM_ERROR("invalid msm_dp_audio data\n");
 		return ERR_PTR(-EINVAL);
@@ -173,16 +186,68 @@ static struct msm_dp_audio_private *msm_dp_audio_get_data(struct msm_dp *msm_dp_
 	return container_of(msm_dp_audio, struct msm_dp_audio_private, msm_dp_audio);
 }
 
-int msm_dp_audio_prepare(struct drm_connector *connector,
-			 struct drm_bridge *bridge,
-			 struct hdmi_codec_daifmt *daifmt,
-			 struct hdmi_codec_params *params)
+static int msm_dp_audio_hook_plugged_cb(struct device *dev, void *data,
+		hdmi_codec_plugged_cb fn,
+		struct device *codec_dev)
+{
+
+	struct platform_device *pdev;
+	struct msm_dp *msm_dp_display;
+
+	pdev = to_platform_device(dev);
+	if (!pdev) {
+		pr_err("invalid input\n");
+		return -ENODEV;
+	}
+
+	msm_dp_display = platform_get_drvdata(pdev);
+	if (!msm_dp_display) {
+		pr_err("invalid input\n");
+		return -ENODEV;
+	}
+
+	return msm_dp_display_set_plugged_cb(msm_dp_display, fn, codec_dev);
+}
+
+static int msm_dp_audio_get_eld(struct device *dev,
+	void *data, uint8_t *buf, size_t len)
+{
+	struct platform_device *pdev;
+	struct msm_dp *msm_dp_display;
+
+	pdev = to_platform_device(dev);
+
+	if (!pdev) {
+		DRM_ERROR("invalid input\n");
+		return -ENODEV;
+	}
+
+	msm_dp_display = platform_get_drvdata(pdev);
+	if (!msm_dp_display) {
+		DRM_ERROR("invalid input\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&msm_dp_display->connector->eld_mutex);
+	memcpy(buf, msm_dp_display->connector->eld,
+		min(sizeof(msm_dp_display->connector->eld), len));
+	mutex_unlock(&msm_dp_display->connector->eld_mutex);
+
+	return 0;
+}
+
+int msm_dp_audio_hw_params(struct device *dev,
+	void *data,
+	struct hdmi_codec_daifmt *daifmt,
+	struct hdmi_codec_params *params)
 {
 	int rc = 0;
 	struct msm_dp_audio_private *audio;
+	struct platform_device *pdev;
 	struct msm_dp *msm_dp_display;
 
-	msm_dp_display = to_dp_bridge(bridge)->msm_dp_display;
+	pdev = to_platform_device(dev);
+	msm_dp_display = platform_get_drvdata(pdev);
 
 	/*
 	 * there could be cases where sound card can be opened even
@@ -197,7 +262,7 @@ int msm_dp_audio_prepare(struct drm_connector *connector,
 		goto end;
 	}
 
-	audio = msm_dp_audio_get_data(msm_dp_display);
+	audio = msm_dp_audio_get_data(pdev);
 	if (IS_ERR(audio)) {
 		rc = PTR_ERR(audio);
 		goto end;
@@ -216,14 +281,15 @@ int msm_dp_audio_prepare(struct drm_connector *connector,
 	return rc;
 }
 
-void msm_dp_audio_shutdown(struct drm_connector *connector,
-			   struct drm_bridge *bridge)
+static void msm_dp_audio_shutdown(struct device *dev, void *data)
 {
 	struct msm_dp_audio_private *audio;
+	struct platform_device *pdev;
 	struct msm_dp *msm_dp_display;
 
-	msm_dp_display = to_dp_bridge(bridge)->msm_dp_display;
-	audio = msm_dp_audio_get_data(msm_dp_display);
+	pdev = to_platform_device(dev);
+	msm_dp_display = platform_get_drvdata(pdev);
+	audio = msm_dp_audio_get_data(pdev);
 	if (IS_ERR(audio)) {
 		DRM_ERROR("failed to get audio data\n");
 		return;
@@ -245,6 +311,47 @@ void msm_dp_audio_shutdown(struct drm_connector *connector,
 	msm_dp_display_signal_audio_complete(msm_dp_display);
 }
 
+static const struct hdmi_codec_ops msm_dp_audio_codec_ops = {
+	.hw_params = msm_dp_audio_hw_params,
+	.audio_shutdown = msm_dp_audio_shutdown,
+	.get_eld = msm_dp_audio_get_eld,
+	.hook_plugged_cb = msm_dp_audio_hook_plugged_cb,
+};
+
+static struct hdmi_codec_pdata codec_data = {
+	.ops = &msm_dp_audio_codec_ops,
+	.max_i2s_channels = 8,
+	.i2s = 1,
+};
+
+void msm_dp_unregister_audio_driver(struct device *dev, struct msm_dp_audio *msm_dp_audio)
+{
+	struct msm_dp_audio_private *audio_priv;
+
+	audio_priv = container_of(msm_dp_audio, struct msm_dp_audio_private, msm_dp_audio);
+
+	if (audio_priv->audio_pdev) {
+		platform_device_unregister(audio_priv->audio_pdev);
+		audio_priv->audio_pdev = NULL;
+	}
+}
+
+int msm_dp_register_audio_driver(struct device *dev,
+		struct msm_dp_audio *msm_dp_audio)
+{
+	struct msm_dp_audio_private *audio_priv;
+
+	audio_priv = container_of(msm_dp_audio,
+			struct msm_dp_audio_private, msm_dp_audio);
+
+	audio_priv->audio_pdev = platform_device_register_data(dev,
+						HDMI_CODEC_DRV_NAME,
+						PLATFORM_DEVID_AUTO,
+						&codec_data,
+						sizeof(codec_data));
+	return PTR_ERR_OR_ZERO(audio_priv->audio_pdev);
+}
+
 struct msm_dp_audio *msm_dp_audio_get(struct platform_device *pdev,
 			struct msm_dp_catalog *catalog)
 {
diff --git a/src/drivers/gpu/drm/msm/dp/dp_audio.h b/src/drivers/gpu/drm/msm/dp/dp_audio.h
index 58fc14693e48..beea34cbab77 100644
--- a/src/drivers/gpu/drm/msm/dp/dp_audio.h
+++ b/src/drivers/gpu/drm/msm/dp/dp_audio.h
@@ -35,6 +35,23 @@ struct msm_dp_audio {
 struct msm_dp_audio *msm_dp_audio_get(struct platform_device *pdev,
 			struct msm_dp_catalog *catalog);
 
+/**
+ * msm_dp_register_audio_driver()
+ *
+ * Registers DP device with hdmi_codec interface.
+ *
+ * @dev: DP device instance.
+ * @msm_dp_audio: an instance of msm_dp_audio module.
+ *
+ *
+ * Returns the error code in case of failure, otherwise
+ * zero on success.
+ */
+int msm_dp_register_audio_driver(struct device *dev,
+		struct msm_dp_audio *msm_dp_audio);
+
+void msm_dp_unregister_audio_driver(struct device *dev, struct msm_dp_audio *msm_dp_audio);
+
 /**
  * msm_dp_audio_put()
  *
@@ -44,12 +61,10 @@ struct msm_dp_audio *msm_dp_audio_get(struct platform_device *pdev,
  */
 void msm_dp_audio_put(struct msm_dp_audio *msm_dp_audio);
 
-int msm_dp_audio_prepare(struct drm_connector *connector,
-			 struct drm_bridge *bridge,
-			 struct hdmi_codec_daifmt *daifmt,
-			 struct hdmi_codec_params *params);
-void msm_dp_audio_shutdown(struct drm_connector *connector,
-			   struct drm_bridge *bridge);
+int msm_dp_audio_hw_params(struct device *dev,
+	void *data,
+	struct hdmi_codec_daifmt *daifmt,
+	struct hdmi_codec_params *params);
 
 #endif /* _DP_AUDIO_H_ */
 
diff --git a/src/drivers/gpu/drm/msm/dp/dp_display.c b/src/drivers/gpu/drm/msm/dp/dp_display.c
index a48e6db4f156..c7503a7a6123 100644
--- a/src/drivers/gpu/drm/msm/dp/dp_display.c
+++ b/src/drivers/gpu/drm/msm/dp/dp_display.c
@@ -13,7 +13,6 @@
 #include <linux/delay.h>
 #include <linux/string_choices.h>
 #include <drm/display/drm_dp_aux_bus.h>
-#include <drm/display/drm_hdmi_audio_helper.h>
 #include <drm/drm_edid.h>
 
 #include "msm_drv.h"
@@ -294,6 +293,13 @@ static int msm_dp_display_bind(struct device *dev, struct device *master,
 		goto end;
 	}
 
+
+	rc = msm_dp_register_audio_driver(dev, dp->audio);
+	if (rc) {
+		DRM_ERROR("Audio registration Dp failed\n");
+		goto end;
+	}
+
 	rc = msm_dp_hpd_event_thread_start(dp);
 	if (rc) {
 		DRM_ERROR("Event thread create failed\n");
@@ -315,6 +321,7 @@ static void msm_dp_display_unbind(struct device *dev, struct device *master,
 
 	of_dp_aux_depopulate_bus(dp->aux);
 
+	msm_dp_unregister_audio_driver(dev, dp->audio);
 	msm_dp_aux_unregister(dp->aux);
 	dp->drm_dev = NULL;
 	dp->aux->drm_dev = NULL;
@@ -633,9 +640,9 @@ static void msm_dp_display_handle_plugged_change(struct msm_dp *msm_dp_display,
 			struct msm_dp_display_private, msm_dp_display);
 
 	/* notify audio subsystem only if sink supports audio */
-	if (dp->audio_supported)
-		drm_connector_hdmi_audio_plugged_notify(msm_dp_display->connector,
-							plugged);
+	if (msm_dp_display->plugged_cb && msm_dp_display->codec_dev &&
+			dp->audio_supported)
+		msm_dp_display->plugged_cb(msm_dp_display->codec_dev, plugged);
 }
 
 static int msm_dp_hpd_unplug_handle(struct msm_dp_display_private *dp, u32 data)
@@ -914,6 +921,19 @@ static int msm_dp_display_disable(struct msm_dp_display_private *dp)
 	return 0;
 }
 
+int msm_dp_display_set_plugged_cb(struct msm_dp *msm_dp_display,
+		hdmi_codec_plugged_cb fn, struct device *codec_dev)
+{
+	bool plugged;
+
+	msm_dp_display->plugged_cb = fn;
+	msm_dp_display->codec_dev = codec_dev;
+	plugged = msm_dp_display->link_ready;
+	msm_dp_display_handle_plugged_change(msm_dp_display, plugged);
+
+	return 0;
+}
+
 /**
  * msm_dp_bridge_mode_valid - callback to determine if specified mode is valid
  * @bridge: Pointer to drm bridge structure
diff --git a/src/drivers/gpu/drm/msm/dp/dp_display.h b/src/drivers/gpu/drm/msm/dp/dp_display.h
index cc6e2cab36e9..ecbc2d92f546 100644
--- a/src/drivers/gpu/drm/msm/dp/dp_display.h
+++ b/src/drivers/gpu/drm/msm/dp/dp_display.h
@@ -7,6 +7,7 @@
 #define _DP_DISPLAY_H_
 
 #include "dp_panel.h"
+#include <sound/hdmi-codec.h>
 #include "disp/msm_disp_snapshot.h"
 
 #define DP_MAX_PIXEL_CLK_KHZ	675000
@@ -14,6 +15,7 @@
 struct msm_dp {
 	struct drm_device *drm_dev;
 	struct platform_device *pdev;
+	struct device *codec_dev;
 	struct drm_connector *connector;
 	struct drm_bridge *next_bridge;
 	bool link_ready;
@@ -23,10 +25,14 @@ struct msm_dp {
 	bool is_edp;
 	bool internal_hpd;
 
+	hdmi_codec_plugged_cb plugged_cb;
+
 	struct msm_dp_audio *msm_dp_audio;
 	bool psr_supported;
 };
 
+int msm_dp_display_set_plugged_cb(struct msm_dp *msm_dp_display,
+		hdmi_codec_plugged_cb fn, struct device *codec_dev);
 int msm_dp_display_get_modes(struct msm_dp *msm_dp_display);
 bool msm_dp_display_check_video_test(struct msm_dp *msm_dp_display);
 int msm_dp_display_get_test_bpp(struct msm_dp *msm_dp_display);
diff --git a/src/drivers/gpu/drm/msm/dp/dp_drm.c b/src/drivers/gpu/drm/msm/dp/dp_drm.c
index f222d7ccaa88..293f4745f1e2 100644
--- a/src/drivers/gpu/drm/msm/dp/dp_drm.c
+++ b/src/drivers/gpu/drm/msm/dp/dp_drm.c
@@ -12,7 +12,6 @@
 
 #include "msm_drv.h"
 #include "msm_kms.h"
-#include "dp_audio.h"
 #include "dp_drm.h"
 
 /**
@@ -115,9 +114,6 @@ static const struct drm_bridge_funcs msm_dp_bridge_ops = {
 	.hpd_disable  = msm_dp_bridge_hpd_disable,
 	.hpd_notify   = msm_dp_bridge_hpd_notify,
 	.debugfs_init = msm_dp_bridge_debugfs_init,
-
-	.dp_audio_prepare = msm_dp_audio_prepare,
-	.dp_audio_shutdown = msm_dp_audio_shutdown,
 };
 
 static int msm_edp_bridge_atomic_check(struct drm_bridge *drm_bridge,
@@ -325,13 +321,9 @@ int msm_dp_bridge_init(struct msm_dp *msm_dp_display, struct drm_device *dev,
 	 */
 	if (!msm_dp_display->is_edp) {
 		bridge->ops =
-			DRM_BRIDGE_OP_DP_AUDIO |
 			DRM_BRIDGE_OP_DETECT |
 			DRM_BRIDGE_OP_HPD |
 			DRM_BRIDGE_OP_MODES;
-		bridge->hdmi_audio_dev = &msm_dp_display->pdev->dev;
-		bridge->hdmi_audio_max_i2s_playback_channels = 8;
-		bridge->hdmi_audio_dai_port = -1;
 	}
 
 	rc = devm_drm_bridge_add(dev->dev, bridge);
-- 
2.51.0

